// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.26;

import {Test} from "forge-std/Test.sol";
import {Wyrd} from "../src/Wyrd.sol";
import {IRandomizer} from "../src/interfaces/ext/IRandomizer.sol";
import {IEntropy} from "@pythnetwork/entropy-sdk-solidity/IEntropy.sol";
import {VRF} from "vrf-solidity/contracts/VRF.sol";

// Mock contracts for testing
contract MockRandomizer is IRandomizer {
    uint256 private constant CALLBACK_GAS = 100_000;
    mapping(address => uint256) private deposits;
    mapping(address => uint256) private reserved;

    function estimateFee(uint256 callbackGasLimit) external pure returns (uint256) {
        return callbackGasLimit * 50 gwei;
    }

    function getFeeStats(uint256) external pure returns (uint256[2] memory) {
        return [uint256(0), uint256(0)];
    }

    function clientBalanceOf(address _client) external view returns (uint256 deposit, uint256 reserved_) {
        return (deposits[_client], reserved[_client]);
    }

    function getRequest(uint256) external pure returns (
        bytes32 result,
        bytes32 dataHash,
        uint256 ethPaid,
        uint256 ethRefunded,
        bytes10[2] memory vrfHashes
    ) {
        return (bytes32(0), bytes32(0), 0, 0, [bytes10(0), bytes10(0)]);
    }

    function request(uint256 callbackGasLimit) external returns (uint256) {
        require(callbackGasLimit <= CALLBACK_GAS, "Gas limit too high");
        uint256 requestId = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender)));
        return requestId;
    }

    function clientDeposit(address client) external payable {
        deposits[client] += msg.value;
    }

    function clientWithdrawTo(address to, uint256 amount) external {
        require(deposits[msg.sender] >= amount, "Insufficient balance");
        deposits[msg.sender] -= amount;
        payable(to).transfer(amount);
    }
}

contract MockPythEntropy is IEntropy {
    uint128 private constant ENTROPY_FEE = 0.01 ether;
    mapping(uint64 => address) private requests;

    function getFee(address) external pure returns (uint128) {
        return ENTROPY_FEE;
    }

    function requestWithCallback(address provider, bytes32 userRandomNumber)
        external
        payable
        returns (uint64)
    {
        require(msg.value >= ENTROPY_FEE, "Insufficient fee");
        uint64 sequenceNumber = uint64(block.timestamp);
        requests[sequenceNumber] = msg.sender;
        return sequenceNumber;
    }

    // Mock fulfillment function for testing
    function mockFulfill(uint64 sequenceNumber, bytes32 randomValue) external {
        address consumer = requests[sequenceNumber];
        // Call consumer's callback
        IEntropyConsumer(consumer)._entropyCallback(sequenceNumber, address(this), randomValue);
    }
}

contract TestWyrd is Test {
    Wyrd internal wyrd;
    MockRandomizer internal randomizer;
    MockPythEntropy internal pythEntropy;

    uint8 internal constant FLAG_PYTH = 1 << 0;
    uint8 internal constant FLAG_RANDOMIZER = 1 << 1;
    uint8 internal constant FLAG_SAV = 1 << 2;

    // Test data from VRF library
    uint256[2] internal SAV_PUBLIC_KEY;
    bytes32 internal constant TEST_MESSAGE = bytes32(0x73616d706c65);

    event RandomnessRequested(uint256 indexed req_id, uint8 indexed flag);
    event RandomnessGenerated(uint256 indexed req_id, uint8 indexed flag);
    event RequestCompleted(uint256 indexed req_id);

    function setUp() public {
        randomizer = new MockRandomizer();
        pythEntropy = new MockPythEntropy();

        // Initialize VRF public key from test data
        SAV_PUBLIC_KEY = [
            0x2c8c31fc9f990c6b55e3865a184a4ce50e09481f2eaeb3e60ec1cea13a6ae645,
            0x64b95e4fdb6948c0386e189b006a29f686769b011704275e4459822dc3328085
        ];
    }

    function test_PythOnly() public {
        wyrd = new Wyrd(
            FLAG_PYTH,
            address(0x1234), // Pyth provider
            address(pythEntropy),
            address(randomizer),
            SAV_PUBLIC_KEY
        );

        uint256 reqId = 1;
        bytes32 alpha = bytes32(uint256(1));

        // Request random number
        uint256 fee = pythEntropy.getFee(address(0x1234));
        vm.expectEmit(true, true, false, true);
        emit RandomnessRequested(reqId, FLAG_PYTH);
        wyrd._request_random{value: fee}(reqId, alpha);

        // Check request status
        (bool active, uint8 remainingSources) = wyrd.get_request_status(reqId);
        assertTrue(active);
        assertEq(remainingSources, FLAG_PYTH);

        // Mock Pyth callback
        uint64 sequenceNumber = uint64(block.timestamp);
        bytes32 beta = bytes32(uint256(2));

        uint256 gasBefore = gasleft();
        pythEntropy.mockFulfill(sequenceNumber, beta);
        uint256 gasUsed = gasBefore - gasleft();

        assertTrue(gasUsed < 500_000, "Pyth callback gas too high");

        // Verify request completion
        (active, remainingSources) = wyrd.get_request_status(reqId);
        assertFalse(active);
        assertEq(remainingSources, 0);

        // Check random value
        (bytes32 rand, bool completed) = wyrd.get_random_value(reqId);
        assertTrue(completed);
        assertEq(rand, beta);
    }

    // Similar test functions for other scenarios...
}
